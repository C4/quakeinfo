#!/usr/bin/python
import json
from datetime import datetime, timedelta
import requests
import isodate
import dateutil.relativedelta
import random

#################################################
### Response helper functions from the tutorial
#################################################

def buildSpeechletResponse(title, output, reprompt_text, should_end_session, speechType): 
    # Passing in `speechType` as an object in order to switch between SSML and plain text
    response = {}
    speechlet = {
        'card': {
            'type': 'Simple',
            'title': title,
            'content': output
        },
        'reprompt': {
            'outputSpeech': {
                'type': 'PlainText',
                'text': reprompt_text
            }
        },
        'shouldEndSession': should_end_session
    }
    response.update(speechlet)
    response.update(speechType)
    print response
    return response


def buildResponse(session_attributes, speechlet_response):
    return {
        'version': '1.0',
        'sessionAttributes': session_attributes,
        'response': speechlet_response
    }

def getErrorResponse():
    errorResponse = ["I couldn't find the answer to your question.", \
                    "I had some trouble looking that up. Please try again.", 
                    "Sorry, I wasn't able to find that." \
                    ]
    return random.choice(errorResponse)

###############
### Functions
###############
def getWelcomeResponse():
    # Welcome message when the skill is invoked

    session_attributes = {}
    card_title = "Welcome to QuakeInfo"
    speech_output = "Welcome to Quake Info.  This provides information about recent earthquakes near you, or, anywhere in the world.   "+ \
                    "You can ask questions like:  What are the recent earthquakes,  or,  Are there any earthquakes near me.  "
    should_end_session = True

    speechType = {'outputSpeech': {'type': 'PlainText','text': speech_output}}
    return buildResponse(session_attributes, buildSpeechletResponse(card_title, speech_output, reprompt_text, should_end_session,speechType))

def handleSessionEndRequest():
    card_title = "Session Ended"
    speech_output = "Thank you for using Quake Info. " \
                    "Stay Safe!"
    # Setting this to true ends the session and exits the skill.
    should_end_session = True
    return buildResponse({}, buildSpeechletResponse(
        card_title, speech_output, None, should_end_session))

def getEarthquakeDefinition(intent, session):
    # Earthquake definition
    session_attributes = {}
    reprompt_text = None
    should_end_session = True
    speech_output = "An earthquake is a tremor of the surface of the Earth, sometimes severe and devastating, which results from shock waves generated by the movement of rock masses deep within the Earth, particularly near boundaries of tectonic plates"
    speechType = {'outputSpeech': {'type': 'PlainText','text': speech_output}}
    return buildResponse(session_attributes, buildSpeechletResponse(intent['name'], speech_output, reprompt_text, should_end_session, speechType),)

def getMagnitudeDefinition(intent, session):
    # Quick explaination of how earthquakes are measured. 
    session_attributes = {}
    reprompt_text = None
    should_end_session = True
    speech_output = "The globally accepted scale for measureing earthquakes is called the 'moment magnitude scale'. The moment magnitude scale is based on the total moment release of the earthquake. Moment is a product of the distance a fault moved and the force required to move it. It is derived from modeling recordings of the earthquake at multiple stations. Moment magnitude estimates are about the same as the Rickter scale magnitudes for small to large earthquakes. But only the moment magnitude scale is capable of measuring magnitude 8.0 and greater events accurately."
    speechType = {'outputSpeech': {'type': 'PlainText','text': speech_output}}
    return buildResponse(session_attributes, buildSpeechletResponse(intent['name'], speech_output, reprompt_text, should_end_session, speechType),)

def getLatLon(city):
    # This function queries the google maps API to find the Lat/Lon. 
    # This is needed in order to send to the USGS API to find the radius
    params = {'address':city,'sensor':'false'}
    url = 'https://maps.googleapis.com/maps/api/geocode/json'
    r = requests.get(url, params)
    data = {}
    if r.status_code == 200:
        response = r.json()
        if 'geometry' in response['results'][0].keys():
            data['lat'] = response['results'][0]['geometry']['location']['lat']
            data['lon'] = response['results'][0]['geometry']['location']['lng']
    else:
        data['errorResponse'] = getErrorResponse()
    return data

def getEarthquakeData(startTime, endTime, minMagnitude, coordinates=None):
    # This function queries the USGS API to get information based on the request from the user. 
    # Docs for the USGS Site: https://earthquake.usgs.gov/fdsnws/event/1/#parameters
    # Example URL: https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=2014-01-01&endtime=2014-01-02
    radius = '483' # Default radius for searching near a location. 483km (~300mi)

    if coordinates:
        params = {'format':'geojson','starttime':startTime,'endtime':endTime,'minmagnitude':minMagnitude,'latitude':coordinates['lat'],'longitude':coordinates['lon'],'maxradiuskm':radius,'orderby':'magnitude'}
    else: 
        params = {'format':'geojson','starttime':startTime,'endtime':endTime,'minmagnitude':minMagnitude,'orderby':'magnitude'}
    url = 'https://earthquake.usgs.gov/fdsnws/event/1/query'
    r = requests.get(url, params)
    data = {}
    if r.status_code == 200:
        response = r.json()
        if len(response['features']) != 0:
            data['magnitude'] = response['features'][0]['properties']['mag']
            data['location'] = response['features'][0]['properties']['place']
            data['time'] = int(response['features'][0]['properties']['time'])/1000 # Converting from milliseconds
        data['count'] = response['metadata']['count']
    else:
        data['errorResponse'] = getErrorResponse()
    
    return data

def getRecentEarthquakes(intent, session):
    # This function is intended to get the recent earthquakes from USGS
    # Setting a default minimum mangnitude to 5.0 and the default duration to 24 hours
    # Todo: Shift for timezones
    magnitude = 5.0
    endTime = datetime.now()
    duration = "24 hours"
    startTime = endTime - timedelta(days=1)
    session_attributes = {}
    reprompt_text = None

    if 'value' in intent['slots']['ActivityDuration'].keys():
        ActivityDuration = intent['slots']['ActivityDuration']['value']
        duration = isodate.parse_duration(ActivityDuration)
        startTime = endTime - duration
        duration = str(duration).split(',') # Todo: figure out how to format this correctly. It's currently `N days, 0:00:00`
        
        earthquakeResponse = getEarthquakeData(startTime,endTime,magnitude)
        if 'errorResponse' in earthquakeResponse.keys():
            speech_output = earthquakeResponse['errorResponse']
        else: 
            speech_output = "There have been "+str(earthquakeResponse['count'])+" earthquakes with a magnitude greater than "+str(magnitude)+" in the past "+str(duration[0])+ \
                            ".  The largest being a "+str(earthquakeResponse['magnitude'])+ " magnitude, located " + str(earthquakeResponse['location']) + " on " + str(datetime.fromtimestamp(earthquakeResponse['time']).strftime('%A %B %d %H:%M %p'))
        should_end_session = True
        speechType = {'outputSpeech': {'type': 'PlainText','text': speech_output}}

    else:
        earthquakeResponse = getEarthquakeData(startTime,endTime,magnitude)
        if 'errorResponse' in earthquakeResponse.keys():
            speech_output = earthquakeResponse['errorResponse']
        else: 
            speech_output = "There have been "+str(earthquakeResponse['count'])+" earthquakes with a magnitude greater than "+str(magnitude)+ \
                        " .  The largest being a "+str(earthquakeResponse['magnitude'])+ " magnitude, located " + str(earthquakeResponse['location']) + " on " + str(datetime.fromtimestamp(earthquakeResponse['time']).strftime('%A %B %d %H:%M %p'))
            
        should_end_session = True
        speechType = {'outputSpeech': {'type': 'PlainText','text': speech_output}}

    return buildResponse(session_attributes, buildSpeechletResponse(intent['name'], speech_output, reprompt_text, should_end_session, speechType),)

def getEarthquakesNearLocation(intent, session, intent_request):
    # Setting some defauts here. Most Places don't have huge earthquakes. Roughly ~2 is about when people can start to "feel" the earthquake. 
    magnitude = 2.0
    endTime = datetime.now()
    duration = "3 days"
    startTime = endTime - timedelta(days=3)
    session_attributes = {}
    reprompt_text = None

    if intent_request['dialogState'] == 'COMPLETED':
        #I'm assuming we have the required slot value at this point
        coordinates = getLatLon(intent['slots']['City']['value'])
        earthquakeResponse = getEarthquakeData(startTime,endTime,magnitude,coordinates)
        if 'errorResponse' in earthquakeResponse.keys():
            speech_output = earthquakeResponse['errorResponse']
        else: 
            print earthquakeResponse['count']
            if earthquakeResponse['count'] == 0:
                speech_output = "There haven't been any recent earthquakes near "+intent['slots']['City']['value']
            else:
                speech_output = "There have been "+str(earthquakeResponse['count'])+" earthquakes with a magnitude greater than "+str(magnitude)+" near "+intent['slots']['City']['value']+ \
                        ".  The largest being a "+str(earthquakeResponse['magnitude'])+ " magnitude, located " + str(earthquakeResponse['location']) + " on " + str(datetime.fromtimestamp(earthquakeResponse['time']).strftime('%A %B %d %H:%M %p'))
        should_end_session = True
        speechType = {'outputSpeech': {'type': 'PlainText','text': speech_output}}

    else:
        # deligate getting the rest of the slot values to alexa.
        response = {
        "version": "1.0",  
        "response": {  
            "shouldEndSession": False,  
            "directives": [{  "type": "Dialog.Delegate"  }]  
            }
        }
        return response
    return buildResponse(session_attributes, buildSpeechletResponse(intent['name'], speech_output, reprompt_text, should_end_session, speechType),)

###############
### Events
###############

def onSessionStarted(session_started_request, session):
    #print("onSessionStarted requestId=" + session_started_request['requestId']+ ", sessionId=" + session['sessionId'])
    print("Session Started.")

def onLaunch(launch_request, session):
    #print("onLaunch requestId=" + launch_request['requestId'] + ", sessionId=" + session['sessionId'])
    return getWelcomeResponse()

def onIntent(intent_request, session):
    #print("onIntent requestId=" + intent_request['requestId'] + ", sessionId=" + session['sessionId'])
    #print(intent_request['intent'])

    intent = intent_request['intent']
    intentName = intent_request['intent']['name']

    # Router for the intent
    if intentName == "RecentEarthquakes":
        return getRecentEarthquakes(intent, session)
    elif intentName == "EarthquakesLocation":
        return getEarthquakesNearLocation(intent, session, intent_request)
    elif intentName == "EarthquakeDefinition":
        return getEarthquakeDefinition(intent, session)
    elif intentName == "MagnitudeDefinition":
        return getMagnitudeDefinition(intent, session)
    elif intentName == "AMAZON.HelpIntent":
        return getWelcomeResponse()
    elif intentName == "AMAZON.CancelIntent" or intentName == "AMAZON.StopIntent":
        return handleSessionEndRequest()
    else:
        raise ValueError("Invalid intent")


def onSessionEnded(session_ended_request, session):
    """ Called when the user ends the session.

    Is not called when the skill returns should_end_session=true
    """
    print("onSessionEnded requestId=" + session_ended_request['requestId'] +
          ", sessionId=" + session['sessionId'])
    # add cleanup logic here




### Main handler

def lambda_handler(event, context):
    # Route the incoming request based on type (LaunchRequest, IntentRequest,etc.) The JSON body of the request is provided in the event parameter.

    print("event.session.application.applicationId=" +
          event['session']['application']['applicationId'])

    """
    Uncomment this if statement and populate with your skill's application ID to
    prevent someone else from configuring a skill that sends requests to this
    function.
    """
    if (event['session']['application']['applicationId'] !=
             "amzn1.ask.skill.a43f1955-6ded-40a3-a9f2-407c3d8708f2"):
         raise ValueError("Invalid Application ID")

    if event['session']['new']:
        onSessionStarted({'requestId': event['request']['requestId']},
                           event['session'])

    if event['request']['type'] == "LaunchRequest":
        return onLaunch(event['request'], event['session'])
    elif event['request']['type'] == "IntentRequest":
        return onIntent(event['request'], event['session'])
    elif event['request']['type'] == "SessionEndedRequest":
        return onSessionEnded(event['request'], event['session'])